Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Кафедра програмної інженерії



ЗВІТ
з практичної роботи №2
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення: Encapsulate 
Field, Split Temporary Variable, Remove Middle Man»



Виконала ст. гр. ПЗПІ-23-9:
Курінна Д. С.

Перевірив:                                                                                                                             
ст. викладач кафедри ПІ
Сокорчук І. П.



Харків 2025
ЗМІСТ
1 ІСТОРІЯ ЗМІН	3
2 ЗАВДАННЯ	4
3 ОПИС ВИКОНАНОЇ РОБОТИ	5
3.1 Вступ	5
3.2 Опис проблеми та доцільність рефакторингу	6
3.2.1 Encapsulate Field – проблема публічних полів	6
3.2.2 Split Temporary Variable – проблема повторного використання змінної	9
3.2.3 Remove Middle Man – проблема зайвого посередника	12
4 ВИСНОВКИ	16
5 ВИКОРИСТАНІ ДЖЕРЕЛА	17
ДОДАТОК А Відеозапис	18
ДОДАТОК Б Слайди презентації	19



1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
17.11.2025
1.0
Створено розділи «Завдання», «Опис виконаної роботи».
2
18.11.2025
1.0
Створено розділи «Використані джерела», «Висновки», «Додаток А», «Додаток Б», «Додаток В». 



2 ЗАВДАННЯ
     Навчитися застосовувати основні методи рефакторингу коду на прикладі власних програмних проєктів, уміти виявляти проблеми в структурі коду та покращувати його якість за допомогою відповідних методів.

3 ОПИС ВИКОНАНОЇ РОБОТИ
     3.1 Вступ
     У процесі розробки програмного забезпечення якість коду відіграє ключову роль у його подальшій підтримці, розширенні та надійності. Навіть коректно працюючий код може містити недоліки в структурі, надмірну складність, дублювання або нечіткість логіки. Тому важливо не лише писати функціональний код, але й уміти його вдосконалювати – застосовувати рефакторинг.
     Рефакторинг дає можливість покращити внутрішню структуру програми, не змінюючи її зовнішню поведінку. Це робить код читабельнішим, зрозумілішим та простішим у підтримці. Одним із найповніших і найпопулярніших джерел з описом технік рефакторингу є книга Мартіна Фаулера «Refactoring. Improving the Design of Existing Code», де наведено понад шістдесят способів удосконалення структури коду.
     У межах даного практичного заняття було обрано три методи рефакторингу, які одночасно є простими в реалізації, широко застосовуються на практиці та дозволяють продемонструвати різні аспекти покращення коду:
1. Encapsulate Field (Інкапсуляція поля) – забезпечує захист даних і дозволяє централізувати перевірку та зміну важливих властивостей об’єкта. Метод обрано для демонстрації базових принципів ООП і покращення контрольованості стану об’єкта.
2. Split Temporary Variable (Розділення тимчасової змінної) – допомагає уникнути ситуацій, коли одна змінна використовується для різних значень. Це суттєво підвищує ясність обчислень і зменшує ризики помилок. Метод обрано через його актуальність у навчальних проєктах, де часто зустрічаються складені розрахунки.
3. Remove Middle Man (Видалення посередника) – спрямований на спрощення архітектури програми шляхом усунення класів або методів, які не виконують реальної роботи, а лише делегують виклики іншим. Обраний метод демонструє вміння аналізувати структуру програми в цілому, а не лише окремі фрагменти коду.
     Обраний набір методів охоплює три різні площини рефакторингу: роботу з полями об’єктів, покращення локальної логіки всередині методу та оптимізацію архітектурних залежностей. Це дозволяє комплексно продемонструвати вміння виявляти проблеми, аргументовано обирати методи покращення та виконувати практичний рефакторинг на власних прикладах коду.
     У подальших розділах роботи кожен із трьох обраних методів буде розглянуто за єдиною структурою, що включає опис вихідної проблеми, фрагмент коду до рефакторингу, обґрунтування вибору відповідного методу, приклад коду після внесених змін та аналіз отриманих переваг. Усі приклади подано мовою TypeScript, яка є поширеним інструментом у сучасних веб-орієнтованих проєктах і забезпечує чіткість типів та наочність показаних трансформацій. Такий підхід дозволяє послідовно продемонструвати вплив застосованих технік на підвищення якості програмного забезпечення та забезпечує наукову коректність викладення матеріалу.
     3.2 Опис проблеми та доцільність рефакторингу
     3.2.1 Encapsulate Field – проблема публічних полів
     Опис проблеми:
     У початковому варіанті мого коду клас User містив публічні поля. На перший погляд це виглядає зручно – будь-яка частина програми може встановити потрібні значення напряму. Проте така зручність швидко перетворюється на проблему.
     Будь-який модуль міг змінити стан користувача без жодної перевірки, що створювало ризик некоректних або випадкових значень. Наприклад, полю age можна було присвоїти -5 або строку, і програма приймала це без заперечень. Це робило клас нестійким до помилок та ускладнювало контроль за його станом.
     Окрім цього, відсутність єдиної точки валідації значила, що будь-які перевірки доводилося дублювати в різних частинах системи. Якщо потрібно було змінити правило або додати нове – це вимагало пошуку та редагування декількох фрагментів коду. Така ситуація негативно впливає на:
• читабельність – складно зрозуміти, де саме відбувається зміна стану;
• підтримуваність – складно гарантувати коректність усіх присвоєнь;
• розширюваність – важко централізовано додати валідацію або нову логіку.
Фактично, будь-яка зміна моделі користувача вимагала серйозних змін по всьому проєкту. Це класичний приклад порушення інкапсуляції.
     Чому Encapsulate Field оптимальний:
     Метод Encapsulate Field дозволяє сховати внутрішні поля за геттерами та сеттерами, створивши чіткий та контрольований інтерфейс доступу.
Це дає можливість:
• централізувати перевірки (валідацію віку, формату email тощо);
• унеможливити некоректні зміни;
• захистити об’єкт від небезпечного зовнішнього впливу;
• модифікувати внутрішню структуру без змін у зовнішньому коді.
Метод ідеально підходить для виправлення цієї проблеми, оскільки він безпосередньо вирішує слабкість моделі – доступність усіх полів напряму.
     Код до рефакторингу:
1 class User {
2   public age: number; // Відкрите поле
3 }
4 
5 const user = new User();
6 
7 // Можна присвоїти будь-що, навіть якщо це суперечить логіці
8 user.age = -5;
     Порядок рефакторингу:
     1. Зміна модифікаторів доступу
     Змініть модифікатор доступу для публічних полів на private. Це закриє прямий доступ до внутрішнього стану.
     2. Додавання методів доступу
     Створіть аксесори (get / set) для полів. Це дозволить зберегти зручний синтаксис звернення (як до змінних), але додасть логіку.
     3. Реалізація валідації.
     Додайте у set перевірку правильності значень. Якщо значення некоректне – викидайте помилку.
4. Перевірка коректності
     Переконайтеся, що зовнішній код тепер працює через захищені методи і не може порушити стан об’єкта.
     Код після рефакторингу:
1 class User {
2   private _age: number; // Поле приховане
3 
4   get age() {
5     return this._age;
6   }
7 
8   set age(value: number) {
9     if (value < 18) throw new Error("Тільки 18+"); // Валідація
10     this._age = value;
11   }
12 }
13 
14 const user = new User();
15 // user.age = 10; // Викине помилку, дані захищені!
     Переваги:
• Контрольований доступ до даних: тепер змінити поле напряму неможливо - усі зміни проходять через методи.
• Централізована валідація: правила перевірки не розкидані по проєкту, а зосереджені всередині класу.
• Відповідність принципам ООП: клас став інкапсульованим, його стан не можна порушити випадковим присвоєнням.
• Підвищена надійність: програмі складніше перейти у неконсистентний стан.
     3.2.2 Split Temporary Variable – проблема повторного використання змінної
     Опис проблеми:
     У вихідному варіанті мого коду було кілька функцій, де одна тимчасова змінна послідовно використовувалася для зберігання абсолютно різних значень.
     Наприклад, змінна temp спершу містила площу фігури, а через кілька рядків – уже середнє значення двох сторін.
     На перший погляд може здатися, що це економить кількість оголошених змінних, але на практиці такий підхід призводить до кількох серйозних проблем.
     По-перше, стає важко зрозуміти, яку саме роль відіграє змінна у кожен момент виконання. Коли одна і та сама назва відповідає кільком різним значенням, читач (а інколи й сам автор коду) витрачає зайвий час на те, щоб пригадати, яке саме значення було перезаписане.
     По-друге, це створює ризик помилок. Якщо змінна використовується для різних обчислень, досить легко випадково застосувати «старе» значення там, де вже мало бути нове. Така ситуація особливо небезпечна у складніших функціях, де логіка містить кілька етапів перерахунку.
     По-третє, переспрямування змінної «на ходу» робить код менш прозорим. Замість того, щоб пояснити логіку через назви змінних (наприклад, area або averageSide), код приховує намір розробника за абстрактним temp, який не відображає ніякого семантичного значення.
     Усе це негативно впливає на:
• читабельність – складніше зрозуміти процес обчислень;
• підтримку – важче вносити зміни, не зламавши існуючу логіку;
• якість налагодження – складніше знайти, у якій точці значення стало неправильним.
     Чому Split Temporary Variable оптимальний:
     Метод Split Temporary Variable безпосередньо вирішує описану проблему: він пропонує замінити одну «багатофункціональну» змінну на кілька окремих, кожна з яких відповідає за свою конкретну роль у розрахунках.
     Це дозволяє:
• зробити логіку прозорою – значення мають осмислені назви;
• унеможливити випадкове змішування різних обчислень;
• зменшити когнітивне навантаження при читанні коду;
• створити код, який «сам себе документує», оскільки назви змінних відображають призначення значень.
     Для розрахункових функцій, які часто зустрічаються у навчальних проєктах, цей метод є одним з найважливіших і найкорисніших.
     Код до рефакторингу:
1 // До рефакторингу: змінна temp
2 // використовується для різних значень
3 function printRectangleInfo(width: number, height: number): void {
4   let temp = width * height; // перше значення - площа
5   console.log("Площа:", temp);
6 
7   // Перезапис змінної, втрата контексту
8   temp = (width + height) / 2; // друге значення - середня довжина сторін
9   console.log("Середнє значення сторін:", temp);
10 }
     Порядок рефакторингу:
     1. Виявлення проблемної змінної
     Проаналізуйте функцію та знайдіть тимчасову змінну, яку використовують для кількох різних значень. Переконайтеся, що змінна справді виконує різні ролі, а не просто зберігає проміжні обчислення одного типу.
     2. Аналіз значень і ролей
     Визначте, які саме значення присвоюються змінній у різних частинах функції. Переконайтеся, що значення несумісні між собою (наприклад, площа та середнє значення сторін).
     3. Створення окремих змінних
     Введіть окрему змінну для кожної ролі.
Надайте змінним семантично зрозумілі назви, які описують їхню суть (наприклад, area, averageSide).
     4. Перенесення логіки в нові змінні
     Скопіюйте відповідні вирази у щойно створені змінні.
Замініть усі звернення до старої змінної (temp) на нові, забезпечивши однозначність логіки.
     5. Перевірка коректності обчислень
     Перевірте, що кожна нова змінна використовується лише для своєї ролі та не перезаписується. Протестуйте функцію, щоб переконатися, що логіка залишилася незмінною, а код став читабельнішим.
     Код після рефакторингу:
1 // Після рефакторингу: чіткі назви, const
2 function printRectangleInfo(width: number, height: number): void {
3   const area = width * height; // Чітка назва
4   console.log("Площа:", area);
5 
6   const averageSide = (width + height) / 2; // Окрема змінна
7   console.log("Середнє значення сторін:", averageSide);
8 }
     Переваги:
• Одна змінна – одна відповідальність. Це відповідає принципам чистого та зрозумілого коду.
• Семантичні назви. area і averageSide одразу пояснюють суть обчислень, без зайвих коментарів.
• Зменшення ризику помилок. Неможливо випадково змішати значення, бо кожне з них живе у власній змінній.
• Покращення читабельності. Навіть людина, яка бачить цей код вперше, одразу розуміє логіку.
• Полегшення налагодження. Якщо одне з обчислень неправильне, виявити це значно легше.
     3.2.3 Remove Middle Man – проблема зайвого посередника
     Опис проблеми:
     У проєкті склалася ситуація, коли клас UserService фактично був «пустишкою». Він не містив власної бізнес-логіки, а всі його методи лише делегували (передавали) виклики іншому об’єкту — репозиторію UserRepository. Цей зайвий рівень абстракції ускладнював навігацію по проєкту: доводилося переходити через додатковий файл, щоб побачити реальну роботу методу. Кожну нову функцію доводилося дублювати і в делегаті, і в посереднику, що створювало ілюзію складності без реальної користі.
     Усе це негативно впливало на:
• простоту розробки – більше кроків виконання простих операцій;
• читабельність – додатковий клас, який не несе сенсу;
• підтримуваність – більше місць для потенційних змін;
• зрозумілість архітектури – зайві рівні абстракції ускладнюють загальну картину системи.
     По суті, UserService виступав “непотрібним посередником” – класом, який нічого не робив самостійно.
     Чому Remove Middle Man оптимальний:
     Цей метод призначений для видалення класів, які не виконують корисної роботи. Він дозволяє позбутися штучних рівнів абстракції та забезпечити прямий доступ клієнта до необхідного функціоналу. Це дає можливість:
• спростити архітектуру системи;
• зменшити кількість коду та файлів;
• працювати напряму з виконавцем там, де немає потреби у сервісному шарі.
     Код до рефакторингу:
1 // До рефакторингу: UserService просто
2 // дублює методи репозиторію
3 class UserService {
4   constructor(private repo: UserRepository) {}
5 
6   getUser(id: number) {
7      // Лише делегує виклик, без логіки
8      return this.repo.getUser(id);
9   }
10 }
11 
12 // Зайвий крок створення сервісу
13 const s = new UserService(new UserRepository());
14 s.getUser(1);
     Порядок рефакторингу:
1. Виявлення посередника
     Знайдіть клас, методи якого лише перенаправляють виклики іншому об’єкту без додаткової логіки чи валідації.
     2. Оновлення клієнтського коду
     У місцях використання посередника замініть його виклики на пряме використання об’єкта-виконавця (UserRepository).
     4. Видалення посередника
     Коли всі виклики перенесені, видаліть клас-посередник (UserService) або спростіть його, якщо залишилась реальна логіка. Переконайтеся, що жоден модуль більше не залежить від цього класу.
     5. Перевірка архітектури та коректності
     Перегляньте структуру модуля: шари мають бути мінімально необхідними.
Протестуйте роботу з UserRepository, щоб переконатися, що бізнес-функціональність збереглася, а код став простішим і прозорішим.
     Код після рефакторингу:
1 // Після рефакторингу
2 // Клас UserService видалено як зайвий
3 
4 // Клієнт працює напряму з виконавцем
5 const repo = new UserRepository();
6 
7 // Прямий, зрозумілий виклик
8 const user = repo.getUser(1);

     Переваги:
• Менше зайвих класів. Архітектура стає легшою та прозорішою.
• Прямий доступ до функціональності. Немає потреби обходити додатковий рівень для виконання простої операції.
• Зменшення зв’язності. Менше залежностей між класами означає легшу підтримку.
• Швидше розуміння коду. Розробнику не потрібно перемикатися між зайвими файлами.
• Відповідність принципу KISS. Код залишається максимально простим там, де складність не приносить користі.

4 ВИСНОВКИ
     У процесі виконання роботи були опрацьовані та застосовані три методи рефакторингу, описані Мартіном Фаулером: Encapsulate Field, Split Temporary Variable та Remove Middle Man. Аналіз власного програмного коду дозволив виявити характерні для навчальних проєктів проблеми, серед яких: неконтрольований доступ до полів об’єктів, повторне використання тимчасових змінних для різних значень та наявність зайвих посередницьких класів.
     Для кожного методу було наведено фрагменти коду «до» і «після» рефакторингу, а також обґрунтовано вибір конкретної техніки для усунення визначеної проблеми. Це дало можливість послідовно продемонструвати, як цілеспрямовані зміни структури програми покращують її внутрішню якість, не змінюючи функціональної поведінки.
     Застосовані методи сприяли підвищенню читабельності, підтримуваності та архітектурної прозорості коду. Інкапсуляція забезпечила контроль над станом об’єктів, розділення тимчасових змінних усунуло логічну плутанину в обчисленнях, а видалення посередника спростило взаємодію між компонентами системи.
     Отже, виконана робота підтвердила, що рефакторинг є важливим етапом життєвого циклу програмного забезпечення та необхідною практикою для забезпечення його надійності, масштабованості й зручності у подальшій підтримці.


5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Fowler M. Refactoring: Improving the Design of Existing Code. 2nd ed. Boston: Addison-Wesley Professional, 2018. – 448 p.
2. Мартін Р. К. Чистий код. Створення, аналіз та рефакторинг за допомогою Agile : пер. з англ. – Київ : Видавнича група «Основи», 2021. – 464 с.
3. Design Patterns and Refactoring. Design Patterns & Refactoring [Електронний ресурс]. – Режим доступу: https://sourcemaking.com/refactoring (дата звернення: 18.11.2025).
4. Microsoft. TypeScript Documentation: Handbook and Reference [Електронний ресурс]. – Режим доступу: https://www.typescriptlang.org/ (дата звернення: 18.11.2025).
5. Refactoring Guru. Refactoring Techniques [Електронний ресурс]. – Режим доступу: https://refactoring.guru/refactoring (дата звернення: 18.11.2025).

ДОДАТОК А
Відеозапис
     Відеозапис доповіді: https://youtu.be/08rOodDIY0I
     Хронологічний опис відеозапису: 
Вступ - 00:23
Методи, що будуть розглядатися - 01:19
Метод «Encapsulate Field» - 02:17
Метод «Split Temporary Variable» - 04:14
Метод «Remove Middle Man» - 05:48
Висновки - 07:07
Використані джерела - 08:02

ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний слайд


Рисунок Б.2 – Вступ


Рисунок Б.3 – Методи, що будуть розглядатися


Рисунок Б.4 – Опис методу «Encapsulate Field»


Рисунок Б.5 – Порядок рефакторингу «Encapsulate Field»


Рисунок Б.6 – Приклад коду «Encapsulate Field»


Рисунок Б.7 – Опис методу «Split Temporary Variable»


Рисунок Б.8 – Порядок рефакторингу «Split Temporary Variable»


Рисунок Б.9 – Приклад коду «Split Temporary Variable»


Рисунок Б.10 – Опис методу «Remove Middle Man»

Рисунок Б.11 – Порядок рефакторингу «Remove Middle Man»


Рисунок Б.12 – Приклад коду «Remove Middle Man»

Рисунок Б.13 – Висновки


Рисунок Б.14 – Використані джерела

2


